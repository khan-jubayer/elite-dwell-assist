'use strict';

var React  = require('react')
var Field  = require('react-input-field/src')
var assign = require('object-assign')
var normalize = require('react-style-normalizer')

function emptyFn(){}

var getSelectionStart = require('./getSelectionStart')
var getSelectionEnd   = require('./getSelectionEnd')
var setSelectionRange = require('./setSelectionRange')

var preventDefault = function(event){
	event.preventDefault()
}

function insert(target, index, what){

	if (index == -1){
		return target.concat(what)
	}

	return target.slice(0, index)
			.concat(what)
			.concat(target.slice(index))
}

module.exports = React.createClass({

	displayName: 'ReactTagField',

	getSelectionStart: function() {
		return getSelectionStart(this.refs.field.getInput())
	},

	getSelectionEnd: function() {
		return getSelectionEnd(this.refs.field.getInput())
	},

	setSelectionRange: function(range) {
		var start = range.start
		var end   = range.end

		setSelectionRange(this.refs.field.getInput(), range)
	},

	getDefaultProps: function() {
		return {
			minInputSize: 3,

			selectedTagStyle: {
				background: 'rgb(200, 200, 200)'
			},
			focusOnClick: true,
			selectableTags: true,

			clearTool: false,
			tagOnBlur: false,
			tagClearTool: false,
			allowDuplicates: false,
			editableTags: true,
			delimiter: ' ',

			tagClearToolColor: '#a8a8a8',

			defaultStyle: {
				overflow: 'hidden'
			},

			defaultInputStyle: {
				flex: 'none',
				alignSelf: 'center',
				// minWidth: 50
			},

			defaultInnerStyle: {
			    display   : 'inline-flex',
			    flexFlow  : 'row wrap'
			},

			defaultTagStyle: {
				display     : 'inline-flex',
				boxSizing: 'border-box',
				alignItems  : 'center',
				flex: 'none',
				flexFlow    : 'row',
				padding: '6px 2px',
				marginLeft  : 2,
				marginTop  : 1,
				marginBottom  : 1,
				border      : '1px solid gray',
				overflow    : 'hidden',
				whiteSpace  : 'nowrap'
			},

			defaultTagClearToolStyle: {
				cursor: 'pointer'
			},

			validateTag: function(x){
				return x !== '' && x != null
			}
		}
	},

	getInitialState: function(){
	    return {
			defaultValue  : this.props.defaultValue,
			defaultTags   : this.props.defaultTags,
			activeTagIndex: -1
	    }
	},

	getValue: function() {
	    var value = this.props.value === undefined?
	                    this.state.defaultValue:
	                    this.props.value

	    return value
	},

	render: function() {

		var props     = this.prepareProps(this.props, this.state)
		var inputSize = Math.max(props.value? props.value.length: 0, this.props.minInputSize)

		return React.createElement(Field, React.__spread({ref: "field"},  props, {inputProps: {size: inputSize}}))
	},

	getInfoForValue: function(value, propsTags) {
		var props          = this.props
		var state          = this.state
		var activeTagIndex = state.activeTagIndex

		var tags     = value.split(props.delimiter)
		var newValue = tags[tags.length - 1]
		var tagMap   = {}

	    if (!props.allowDuplicates){
	    	propsTags = propsTags || this.prepareTags(this.props)

		    propsTags.forEach(function(tag, index){
		    	if (index != activeTagIndex){
			    	tagMap[tag] = true
			    }
		    })
		}

	    tags = tags.slice(0, tags.length - 1).filter(function(x){
	    	return x && !tagMap[x]
	    })

	    return {
			tags : tags,
			value: newValue
	    }

	},

	handleClick: function(props, event) {

		if (!event.nativeEvent.tagClick){
			this.props.focusOnClick && this.focus()
			this.setState({
				activeTagIndex: -1
			})
		}

		;(this.props.onClick || emptyFn)(event)
	},

	handleBlur: function(props, event) {
		if (props.tagOnBlur && props.validateTag(props.value)){
			this.handleChange(props, props.value + props.delimiter, null, event)
		}

		;(this.props.onBlur || emptyFn)(event)
	},

	handleChange: function(props, value, inputProps, event){
		var state   = this.state
		var info    = this.getInfoForValue(value, props.tags)
		var newTags = info.tags

		var allTags = props.editableTags?
						insert(props.tags, state.activeTagIndex, newTags):
						[].concat(props.tags).concat(newTags)

		if (newTags.length && state.activeTagIndex != -1 && props.editableTags){
			this.setState({
				activeTagIndex: state.activeTagIndex + 1
			})
		}

		this.notifyChange(props, info.value, allTags, event)
	},

	notifyChange: function(props, newValue, allTags, event) {

		var newState = {}

    	;(this.props.onChangeTags || emptyFn)(allTags)

    	if (this.props.tags == null){
    	    newState.defaultTags = allTags
    	}

	    if (this.props.value == null){
	    	newState.defaultValue = newValue
	    }

	    this.setState(newState)

	    ;(this.props.onChange || emptyFn)(newValue, this.props, event)
	},

	handleKeyDown: function(props, event) {

		var key = event.key

		if (this.props.onKeyDown){
			this.props.onKeyDown(event)
		}

		if (!props.tags.length || !props.editableTags){
			return
		}

		if (key != 'Backspace' && key != 'ArrowLeft' && key != 'ArrowRight' && key != 'Delete'){
			return
		}

		var value = props.value + ''
		var index = this.state.activeTagIndex
		var tags  = props.tags

		var textToLeft
		var textToRight

		var selectionStart = this.getSelectionStart()
		var selectionEnd   = this.getSelectionEnd()

		if (selectionStart < selectionEnd){
			return
		}

		if (key == 'ArrowLeft' || key == 'Backspace'){
			textToLeft = value.substring(0, selectionStart)
		}

		if (key == 'ArrowRight' || key == 'Delete'){
			textToRight = value.substring(selectionEnd)
		}

		if ((key == 'Backspace' || key == 'ArrowLeft') && textToLeft === ''){

			//if there is no other character at the left of the cursor,
			//go to the tag before the cursor

			if (index == -1){
				index = tags.length
			}

			index--

			if (index >= 0){
				this.setActiveTagIndex(props, index)
				event.preventDefault()
			}
		}

		if ((key == 'ArrowRight' || key == 'Delete') && textToRight == '' && tags[index]){
			event.preventDefault()
			this.setActiveTagIndex(props, index, function(){
				this.setSelectionRange({start: 0, end: 0})
			}.bind(this))
		}
	},

	removeTag: function(props, index) {
		var allTags = this.tags.filter(function(tag, i){
			return i !== index
		})

		var activeTagIndex = this.state.activeTagIndex
		if (activeTagIndex != -1 && activeTagIndex > index){
			//an item was removed from before the editing tag
			//so bring the editing index one down
			this.setState({
				activeTagIndex: activeTagIndex - 1
			})
		}

		this.notifyChange(props, props.value, allTags)
	},

	setActiveTagIndex: function(props, index, callback) {
		var currentValue     = props.value
		var shouldAddCurrent = props.validateTag(currentValue)

		var state   = this.state
		var value

		var allTags = []
		var tags    = this.tags
		var i       = 0
		var len     = tags.length

		var activeTagIndex = state.activeTagIndex
		var tag

		if (props.editableTags){

			var addCurrentValue
			var addCurrentTag

			for (; i < len; i++){
				tag = tags[i]

				addCurrentValue = i == activeTagIndex
				addCurrentTag   = i != index

				if (addCurrentValue){
					shouldAddCurrent && allTags.push(currentValue)
				}
				if (addCurrentTag){
					allTags.push(tag)
				} else {
					value = tag
				}
			}

			if (activeTagIndex == -1){
				shouldAddCurrent && allTags.push(currentValue)
			} else {
				if (shouldAddCurrent && index >= activeTagIndex){
					//the current value was added
					index++
				}
			}
		} else {
			allTags = tags
			value = currentValue
		}

		if (index >= allTags.length){
			index = -1
		}
		if (index < 0){
			index = -1
		}

		this.setState({
			activeTagIndex: index
		}, callback || emptyFn)

		this.notifyChange(props, value, allTags)
	},

	prepareProps: function(thisProps, state) {
		var props = assign({}, thisProps)

		this.prepareStyles(props, state)

		props.tagStyle       = this.prepareTagStyle(props, state)
		props.tags           = this.tags = this.prepareTags(props)
		props.value          = this.prepareValue(props, state)
		props.renderChildren = this.renderChildren.bind(this, props)

		props.onChange  = this.handleChange.bind(this, props)
		props.onBlur    = this.handleBlur.bind(this, props)
		props.onKeyDown = this.handleKeyDown.bind(this, props)
		props.onClick   = this.handleClick.bind(this, props)

		props.focusOnClick = false

		return props
	},

	prepareStyles: function(props, state) {
		props.style = this.prepareStyle(props, state)
		props.innerStyle = assign({}, props.defaultInnerStyle, props.innerStyle)
		props.inputStyle = assign({}, props.defaultInputStyle, props.inputStyle)

		props.tagClearToolStyle = this.prepareTagClearToolStyle(props, state)


		delete props.defaultStyle
		delete props.defaultInnerStyle
		delete props.defaultInputStyle
	},

	prepareTagClearToolStyle: function(props, state) {
		var style = assign({}, props.defaultTagClearToolStyle, {
			color: props.tagClearToolColor
		}, props.tagClearToolStyle)

		return style
	},

	prepareStyle: function(props) {
		var style = assign({}, props.defaultStyle, props.style)

		return style
	},

	prepareValue: function(props, state) {
	    return this.getValue()
	},

	prepareTags: function(props) {
		var tags  = props.tags
		var state = this.state

		if (tags == null){
			tags = state.defaultTags
		}

		tags = Array.isArray(tags) && tags.length? [].concat(tags): []

		return tags.filter(props.validateTag)
	},

	prepareTagStyle: function(props, state) {
		return assign({}, props.defaultTagStyle, props.tagStyle)
	},

	renderChildren: function(props, children) {
		var result = children
		var state = this.state

		var tags = props.tags

		if (tags.length){
			tags = tags.map(function(tag, index){
				return this.renderTag(props, tag, index)
			}, this)

			if (state.activeTagIndex == -1 || !props.editableTags){
				result = tags.concat(children)
			} else {
				result = tags.slice(0, state.activeTagIndex)
							.concat(children)
							.concat(tags.slice(state.activeTagIndex))
			}
		}

		result.push(this.renderHiddenField(props))

		return result
	},

	renderHiddenField: function(props) {
		if (props.editableTags){
			return
		}

		return React.createElement("input", {
			key: "hiddenFocusField", 
			type: "text", 
			ref: "hiddenFocusField", 
			onFocus: this.onHiddenFocus, 
			onKeyDown: this.onHiddenKeyDown.bind(this, props), 
			style: {
				opacity: 0,
				width: 0,
				height: 0,
				margin: 0,
				boxSizing: 'border-box',
				border: 0
				// visibility: 'hidden'
			}}
		)
	},

	onHiddenKeyDown: function(props, event){

		event.preventDefault()

		var tags = this.tags
		var len = tags.length
		var activeTagIndex = this.state.activeTagIndex

		if (!len){
			return
		}

		var key = event.key

		var dir

		if (key == 'ArrowLeft'){
			dir = -1
		}
		if (key == 'ArrowRight'){
			dir = 1
		}

		var newIndex

		if (dir){
			newIndex = activeTagIndex + dir

			if (newIndex < 0){
				newIndex = len - 1
			}

			if (newIndex >= len){
				newIndex = 0
			}
			this.setActiveTagIndex(props, newIndex)

		} else {

			if (key == 'Delete' || key == 'Backspace'){
				this.removeTag(props, activeTagIndex)

				if (key == 'Backspace' || activeTagIndex === len - 1){
					newIndex = activeTagIndex - 1
					if (newIndex < 0){
						newIndex = 0
					}
					setTimeout(function(){
						this.setActiveTagIndex(props, newIndex)
					}.bind(this), 0)
				}

				if (len == 1){
					this.focus()
				}
			}

			if (key == 'Escape'){
				this.setActiveTagIndex(props, -1)
				this.focus()
				return
			}
		}
	},

	focusHidden: function() {
		this.getFocusField().getDOMNode().focus()
	},

	getFocusField: function(){
		return this.refs.field.refs.hiddenFocusField
	},

	renderTag: function(props, tag, index) {
		var tool
		var tagClearTool = props.tagClearTool

		if (tagClearTool){
			if (typeof tagClearTool == 'function'){
				tool = tagClearTool()
			} else {
				tool = React.createElement("span", {style: props.tagClearToolStyle, onClick: this.onTagClearClick.bind(this, props, tag, index)}, "✖")
			}
		}

		var tagStyle = props.tagStyle

		if (!props.editableTags && index == this.state.activeTagIndex && props.selectableTags){
			tagStyle = assign({}, tagStyle, props.selectedTagStyle)
		}

		return React.createElement("span", {key: index, style: tagStyle, onMouseDown: preventDefault, onClick: this.onTagClick.bind(this, props, tag, index)}, 
			tag, 
			tool
		)
	},

	onTagClick: function(props, tag, index, event) {
		if (props.selectableTags){
			this.focusHidden()
		}

		event.nativeEvent.tagClick = true

		if (event.nativeEvent.clearTag){
			return
		}

		this.setActiveTagIndex(props, index)
	},

	onTagClearClick: function(props, tag, index, event){
		event.nativeEvent.clearTag = true
		this.removeTag(props, index)
	},

	notify: function(value, event) {
	    var field = this.refs.field

	    field.notify(value, event)
	},

	focus: function(value, event) {
	    this.refs.field.focus()
	}
})